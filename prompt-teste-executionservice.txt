Guia de Teste - ExecutionService: Fluxo de Execu√ß√£o de Ordens de Servi√ßo
===========================================================================

Ol√° time de ExecutionService!

Agora que o deploy foi conclu√≠do com sucesso, vamos testar a responsabilidade principal do microservi√ßo: INICIAR E EXECUTAR ORDENS DE SERVI√áO.

FLUXO ESPERADO
==============

1. ExecutionService consome evento PaymentConfirmed da fila SQS
2. Cria um ExecutionJob com status inicial "Queued"
3. ExecutionWorker processa o job mudando status: Queued ‚Üí Diagnosing ‚Üí Repairing ‚Üí Finished
4. Publica evento ExecutionStarted (quando inicia o diagn√≥stico)
5. Publica evento ExecutionFinished (quando completa o reparo)


ETAPA 1: VERIFICAR O DEPLOYMENT E PODS
=======================================

Primeiro, verifique se o pod est√° rodando corretamente:

    kubectl get pods -n default | grep execution

Sa√≠da esperada:
    executionservice-xxxxxxxxx-xxxxx   1/1     Running   0          5m

Se o pod n√£o estiver Running, verifique os eventos:

    kubectl describe pod <pod-name> -n default

Para ver os logs em tempo real:

    kubectl logs -f <pod-name> -n default

Procure por mensagens que indicam que os servi√ßos foram iniciados:
    ‚úÖ SqsConsumerService iniciado
    ‚úÖ OutboxProcessor iniciado
    ‚úÖ ExecutionWorker iniciado


ETAPA 2: CRIAR PORT-FORWARD PARA ACESSO LOCAL
==============================================

Crie um port-forward para acessar o pod localmente (assumindo que a API exp√µe porta 8080):

    kubectl port-forward <pod-name> 5003:8080 -n default &

Isso mapeia a porta 8080 do container para a porta 5003 local.

Verifique se o port-forward est√° ativo:

    curl http://localhost:5003/health || curl http://localhost:5003/

Se retornar resposta, o port-forward est√° funcionando!


ETAPA 3: OP√á√ÉO A - SIMULAR EVENTO PaymentConfirmed (TESTE ISOLADO)
===================================================================

Se o ExecutionService tem um endpoint de teste para simular o consumo de PaymentConfirmed:

    curl -X POST http://localhost:5003/api/testing/payment-confirmed \
      -H "Content-Type: application/json" \
      -d '{
        "osId": "9b8e1234-5678-90ab-cdef-123456789abc",
        "paymentId": 999,
        "providerPaymentId": "MP-TEST-999",
        "status": "Confirmed"
      }'

Sa√≠da esperada:
    {"message":"PaymentConfirmed processado com sucesso","jobId":123}

OU, se n√£o houver endpoint de teste, use a OP√á√ÉO B abaixo.


ETAPA 3: OP√á√ÉO B - USAR EVENTO REAL DO SQS (TESTE DE INTEGRA√á√ÉO)
=================================================================

Se j√° existem mensagens PaymentConfirmed na fila SQS do BillingService:

1. Verifique se o SqsConsumerService est√° consumindo:

    kubectl logs -f <pod-name> -n default | grep "PaymentConfirmed"

2. Voc√™ deve ver logs como:
    [SqsConsumerService] Mensagem recebida: PaymentConfirmed
    [PaymentConfirmedHandler] Processando pagamento confirmado para OS: 9b8e1234-5678-90ab-cdef-123456789abc
    [PaymentConfirmedHandler] ExecutionJob criado com sucesso: JobId=123

Se n√£o houver mensagens na fila, pe√ßa ao BillingService para enviar uma nova executando:

    # No BillingService
    curl -X POST http://localhost:5001/api/billing/payments/<osId>/start


ETAPA 4: MONITORAR LOGS DO ExecutionWorker
===========================================

Acompanhe os logs para ver a progress√£o do job:

    kubectl logs -f <pod-name> -n default | grep -E "ExecutionWorker|ExecutionJob"

Sa√≠da esperada (sequ√™ncia):

    [ExecutionWorker] Processando job 123: Status=Queued
    [ExecutionWorker] Iniciando diagn√≥stico para OS 9b8e1234-5678-90ab-cdef-123456789abc
    [ExecutionWorker] Job 123 mudou para: Diagnosing
    ‚úÖ OutboxMessage (ExecutionStarted) criada: OutboxMessageId=456
    
    [ExecutionWorker] Diagn√≥stico conclu√≠do, iniciando reparo
    [ExecutionWorker] Job 123 mudou para: Repairing
    
    [ExecutionWorker] Reparo conclu√≠do com sucesso
    [ExecutionWorker] Job 123 mudou para: Finished
    ‚úÖ OutboxMessage (ExecutionFinished) criada: OutboxMessageId=457


ETAPA 5: VALIDAR PUBLICA√á√ÉO DE EVENTOS NO OUTBOX
=================================================

Verifique se o OutboxProcessor est√° publicando os eventos:

    kubectl logs -f <pod-name> -n default | grep "OutboxProcessor"

Sa√≠da esperada:

    [OutboxProcessor] Processando 2 mensagens pendentes
    [OutboxProcessor] Publicando mensagem 456: ExecutionStarted
    ‚úÖ OutboxMessage (ExecutionStarted) publicada com sucesso no SNS
    [OutboxProcessor] Publicando mensagem 457: ExecutionFinished
    ‚úÖ OutboxMessage (ExecutionFinished) publicada com sucesso no SNS


ETAPA 6: VERIFICAR DADOS NO BANCO (OPCIONAL)
=============================================

Se quiser validar os dados persistidos, fa√ßa port-forward do banco:

    kubectl port-forward <postgres-pod> 5432:5432 -n default &

Conecte via psql ou DBeaver e execute:

    SELECT 
        id, 
        os_id, 
        status, 
        started_at, 
        finished_at,
        created_at
    FROM execution_jobs
    WHERE os_id = '9b8e1234-5678-90ab-cdef-123456789abc'
    ORDER BY created_at DESC;

Resultado esperado:
    id  | os_id                                | status   | started_at          | finished_at         | created_at
    ----+--------------------------------------+----------+---------------------+---------------------+---------------------
    123 | 9b8e1234-5678-90ab-cdef-123456789abc | Finished | 2026-02-19 10:30:00 | 2026-02-19 10:32:00 | 2026-02-19 10:30:00


ETAPA 7: VALIDAR EVENTOS NO SQS (OUTROS SERVI√áOS)
==================================================

Os eventos ExecutionStarted e ExecutionFinished devem estar dispon√≠veis para outros servi√ßos via SNS‚ÜíSQS.

Para verificar se foram publicados, monitore os logs de servi√ßos consumidores (como NotificationService, se existir).

Ou use AWS CLI para verificar mensagens nas filas:

    aws sqs receive-message \
      --queue-url https://sqs.sa-east-1.amazonaws.com/953082827427/notification-events \
      --region sa-east-1 \
      --max-number-of-messages 10

Procure por mensagens com EventType: ExecutionStarted e ExecutionFinished.


CHECKLIST DE VALIDA√á√ÉO
=======================

[ ] Pod est√° Running (1/1)
[ ] Port-forward criado com sucesso (porta 5003)
[ ] Endpoint de sa√∫de responde (GET /health)
[ ] PaymentConfirmed consumido da fila (via logs)
[ ] ExecutionJob criado com status Queued (via logs)
[ ] ExecutionWorker processou: Queued ‚Üí Diagnosing (via logs)
[ ] Evento ExecutionStarted publicado no OutboxProcessor (via logs)
[ ] ExecutionWorker processou: Diagnosing ‚Üí Repairing (via logs)
[ ] ExecutionWorker processou: Repairing ‚Üí Finished (via logs)
[ ] Evento ExecutionFinished publicado no OutboxProcessor (via logs)
[ ] Registro criado na tabela execution_jobs com status Finished (via DB)
[ ] Eventos dispon√≠veis no SNS/SQS para consumo de outros servi√ßos


COMANDOS √öTEIS RESUMIDOS
=========================

# Ver pods
kubectl get pods -n default | grep execution

# Logs em tempo real
kubectl logs -f <pod-name> -n default

# Filtrar logs espec√≠ficos
kubectl logs -f <pod-name> -n default | grep -E "ExecutionWorker|Outbox|PaymentConfirmed"

# Port-forward
kubectl port-forward <pod-name> 5003:8080 -n default &

# Testar API
curl http://localhost:5003/health

# Simular PaymentConfirmed (se endpoint existir)
curl -X POST http://localhost:5003/api/testing/payment-confirmed \
  -H "Content-Type: application/json" \
  -d '{"osId":"9b8e1234-5678-90ab-cdef-123456789abc","paymentId":999,"status":"Confirmed"}'

# Matar port-forward
pkill -f "port-forward.*5003"


TROUBLESHOOTING
===============

PROBLEMA 1: Pod n√£o sobe (CrashLoopBackOff)
-------------------------------------------
Verifique os logs:
    kubectl logs <pod-name> -n default --previous

Causas comuns:
- Vari√°veis de ambiente faltando (AWS_REGION, DB_HOST, etc.)
- Credenciais AWS inv√°lidas
- Banco de dados inacess√≠vel


PROBLEMA 2: PaymentConfirmed n√£o √© consumido
---------------------------------------------
Verifique:
1. SqsConsumerService est√° rodando? (logs devem mostrar "SqsConsumerService iniciado")
2. Fila SQS est√° correta no ConfigMap? (AWS_SQS_QUEUE_EXECUTION)
3. Credenciais AWS est√£o corretas no Secret?
4. Regi√£o AWS est√° correta? (aws-region: sa-east-1)

Debug:
    kubectl logs -f <pod-name> -n default | grep -i "sqs\|consumer"


PROBLEMA 3: ExecutionWorker n√£o processa jobs
----------------------------------------------
Verifique:
1. ExecutionWorker est√° rodando? (logs devem mostrar "ExecutionWorker iniciado")
2. Job foi criado no banco? (SELECT * FROM execution_jobs)
3. H√° erros no log do worker?

Debug:
    kubectl logs -f <pod-name> -n default | grep -i "worker\|job"


PROBLEMA 4: Eventos n√£o s√£o publicados no SNS
----------------------------------------------
Verifique:
1. OutboxProcessor est√° rodando? (logs devem mostrar "OutboxProcessor iniciado")
2. Mensagens foram criadas na tabela outbox_messages?
3. ARNs do SNS est√£o corretos no ConfigMap?

Debug:
    kubectl logs -f <pod-name> -n default | grep -i "outbox\|sns"


ESTRUTURA DE EVENTOS ESPERADOS
===============================

ExecutionStarted:
-----------------
{
  "EventType": "ExecutionStarted",
  "OsId": "9b8e1234-5678-90ab-cdef-123456789abc",
  "ExecutionJobId": 123,
  "StartedAt": "2026-02-19T10:30:00Z",
  "CorrelationId": "626bd763-c258-4563-9dc5-ac10191b9c69",
  "CausationId": "a1b2c3d4-e5f6-7890-abcd-ef1234567890"
}

ExecutionFinished:
------------------
{
  "EventType": "ExecutionFinished",
  "OsId": "9b8e1234-5678-90ab-cdef-123456789abc",
  "ExecutionJobId": 123,
  "Status": "Completed",
  "FinishedAt": "2026-02-19T10:32:00Z",
  "CorrelationId": "626bd763-c258-4563-9dc5-ac10191b9c69",
  "CausationId": "626bd763-c258-4563-9dc5-ac10191b9c69"
}


TESTE E2E COMPLETO (COM BILLINGSERVICE)
========================================

Para validar a integra√ß√£o completa:

1. No OSService, crie uma OS (status: Aberta)
2. No BillingService, gere or√ßamento para a OS
3. Aprove o or√ßamento (muda para Aprovado)
4. Inicie pagamento (BillingService publica PaymentConfirmed)
5. ExecutionService consome PaymentConfirmed ‚Üí cria job ‚Üí executa ‚Üí publica eventos
6. Valide CorrelationId em todos os eventos (deve ser o mesmo da OS original)

Comando trace E2E:
    kubectl logs -f <billing-pod> -n default | grep <correlation-id> &
    kubectl logs -f <execution-pod> -n default | grep <correlation-id> &


SUCESSO!
========

Se todos os checkpoints foram validados, o ExecutionService est√° funcionando corretamente! üéâ

Os pr√≥ximos passos seriam:
- Testes de carga (m√∫ltiplas OSs simult√¢neas)
- Testes de falha (job falha no diagn√≥stico/reparo)
- Monitoramento cont√≠nuo (Prometheus/Grafana)
- Alertas (quando jobs ficam muito tempo em Queued/Diagnosing)

Qualquer d√∫vida, s√≥ chamar!
